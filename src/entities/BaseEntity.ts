import {
  Entity,
  ModelEntityOptions,
  MoveOptions,
  PathfindingEntityController,
  PathfindingOptions,
  Quaternion,
  QuaternionLike,
  RigidBodyType,
  SceneUI,
  Vector3Like,
  World,
} from 'hytopia';

import { SkillId } from '../config';
import GamePlayerEntity from '../GamePlayerEntity';
import QuestRegistry, { QUEST_DIALOGUE_OPTION_START_ID } from '../quests/QuestRegistry';
import type IInteractable from '../interfaces/IInteractable';
import type IDamageable from '../interfaces/IDamageable';
import type { ItemClass } from '../items/BaseItem';

export enum BaseEntityPlayerEvent {
  KILLED = 'BaseEntity.KILLED',
}

export type BaseEntityPlayerEventPayloads = {
  [BaseEntityPlayerEvent.KILLED]: { entity: BaseEntity };
}

export type BaseEntityDialogue = {
  text: string;
  options?: BaseEntityDialogueOption[];
}

export type BaseEntityDialogueOption = {
  _id?: number; // internal autogenerated option id
  text: string;
  dismiss?: boolean;
  isSelectable?: (interactor: GamePlayerEntity) => boolean;
  nextDialogue?: BaseEntityDialogue;
  onSelect?: (interactor: GamePlayerEntity) => void;
  pureExit?: boolean;
}

export type BaseEntityDialogueRoot = {
  avatarImageUri: string;
  title?: string;
  dialogue: BaseEntityDialogue;
}

export type BaseEntityItemDrop = {
  itemClass: ItemClass;
  maxQuantity?: number;
  minQuantity?: number;
  weight: number;
  quantity?: number;
}

export type BaseEntityNameplateType = 'normal' | 'boss';

export type BaseEntityOptions = {
  combatExperienceReward?: number;
  controller?: PathfindingEntityController;
  deathAnimations?: string[];
  deathDespawnDelayMs?: number;
  deathItemDrops?: BaseEntityItemDrop[];
  deathItemMaxDrops?: number;
  dialogue?: BaseEntityDialogueRoot;
  faceSpeed?: number;
  facingAngle?: number;
  facingPosition?: Vector3Like;
  idleAnimations?: string[];
  idleAnimationSpeed?: number;
  interactActionText?: string;
  health?: number;
  moveAnimations?: string[];
  moveAnimationSpeed?: number;
  moveOptions?: MoveOptions;
  moveSpeed?: number;
  nameplateType?: BaseEntityNameplateType;
  nameplateViewDistnace?: number;
  pathfindingOptions?: PathfindingOptions;
  rotatesOnInteract?: boolean;
  pushable?: boolean;
} & ModelEntityOptions;

export type WanderOptions = {
  idleMinMs: number;
  idleMaxMs: number;
  maxWanderRadius: number;
  moveOptions?: MoveOptions;
}

export default class BaseEntity extends Entity implements IInteractable, IDamageable {
  private _combatExperienceReward: number;
  private _deathAnimations: string[];
  private _deathDespawnDelayMs: number;
  private _deathItemDrops: BaseEntityItemDrop[];
  private _deathItemDropsTotalWeight: number = 0;
  private _deathItemMaxDrops: number;
  private _dialogueRoot: BaseEntityDialogueRoot | undefined;
  private _dying: boolean = false;
  private _faceSpeed: number;
  private _health: number;
  private _interactActionText: string | undefined;
  private _maxHealth: number;
  private _moveOptions: MoveOptions | undefined;
  private _moveSpeed: number; 
  private _nameplateSceneUI: SceneUI;
  private _nameplateType: BaseEntityNameplateType | undefined; 
  private _nameplateViewDistance: number | undefined;
  private _optionMap: Map<number, BaseEntityDialogueOption> = new Map();
  private _pathfindingOptions: PathfindingOptions | undefined;
  private _pushable: boolean;
  private _rotatesOnInteract: boolean;
  private _wanderTimeout: NodeJS.Timeout | undefined;
  
  public constructor(options: BaseEntityOptions = {}) {
    super({
      ...options,
      controller: new PathfindingEntityController(),
      rigidBodyOptions: {
        ...options.rigidBodyOptions,
        type: RigidBodyType.DYNAMIC,
        enabledRotations: { x: false, y: true, z: false },
        rotation: Quaternion.fromEuler(0, options.facingAngle ?? 0, 0),
        additionalMass: !options.pushable ? 1000 : 0,
      }
    });

    this._combatExperienceReward = options.combatExperienceReward ?? 0;
    this._deathAnimations = options.deathAnimations ?? [];
    this._deathDespawnDelayMs = options.deathDespawnDelayMs ?? 0;
    this._deathItemDrops = options.deathItemDrops ?? [];
    this._deathItemDropsTotalWeight = this._deathItemDrops.reduce((sum, drop) => sum + drop.weight, 0);
    this._deathItemMaxDrops = options.deathItemMaxDrops ?? 1;
    this._dialogueRoot = options.dialogue;
    this._health = options.health ?? 0; // 0 is infinite health, will not show health bar
    this._interactActionText = options.interactActionText;
    this._maxHealth = this._health;
    this._moveOptions = options.moveOptions;
    this._moveSpeed = options.moveSpeed ?? 2;
    this._faceSpeed = options.faceSpeed ?? this._moveSpeed * 2;
    this._nameplateType = options.nameplateType;
    this._nameplateViewDistance = options.nameplateViewDistnace;
    this._pathfindingOptions = options.pathfindingOptions;
    this._pushable = options.pushable ?? false;
    this._rotatesOnInteract = options.rotatesOnInteract ?? true;

    if (this._dialogueRoot) {
      this._buildDialogueOptionMap();
    }

    this.pathfindingController.idleLoopedAnimations = options.idleAnimations ?? [];
    this.pathfindingController.idleLoopedAnimationsSpeed = options.idleAnimationSpeed ?? undefined;
    this.pathfindingController.moveLoopedAnimations = options.moveAnimations ?? [];
    this.pathfindingController.moveLoopedAnimationsSpeed = options.moveAnimationSpeed ?? undefined;

    if (options.facingPosition) {
      this.pathfindingController.face(options.facingPosition, this._moveSpeed);
    }

    this.setupNameplateUI();
  }

  public get dialogueRoot(): BaseEntityDialogueRoot | undefined { return this._dialogueRoot; }
  public get faceSpeed(): number { return this._faceSpeed; }
  public get idleAnimations(): string[] { return this.pathfindingController.idleLoopedAnimations; }
  public get idleAnimationsSpeed(): number | undefined { return this.pathfindingController.idleLoopedAnimationsSpeed; }
  public get interactActionText(): string | undefined { return this._interactActionText; }
  public get isDead(): boolean { return this._dying; }
  public get isInteractable(): boolean { return !!this._dialogueRoot || !!this._interactActionText; }
  public get health(): number { return this._health; }
  public get maxHealth(): number { return this._maxHealth; }
  public get moveAnimations(): string[] { return this.pathfindingController.moveLoopedAnimations; }
  public get moveAnimationsSpeed(): number | undefined { return this.pathfindingController.moveLoopedAnimationsSpeed; }
  public get moveSpeed(): number { return this._moveSpeed; }
  public get pathfindingOptions(): PathfindingOptions | undefined { return this._pathfindingOptions; }
  public get pathfindingController(): PathfindingEntityController { return this.controller as PathfindingEntityController; }
  public get pushable(): boolean { return this._pushable; }

  public adjustHealth(amount: number, attacker?: Entity): void {
    // ignore if maHealth is 0 (infinite), or full health and positive amount, or dead and negative amount
    if (this._maxHealth === 0 || (amount > 0 && this._health === this.maxHealth) || (amount < 0 && this._health === 0)) return;

    this._health = Math.max(0, Math.min(this.maxHealth, this._health + amount));

    this._nameplateSceneUI.setState({
      health: this._health
    });

    if (this._health <= 0) {
      this.die(attacker);
    }
  }

  public die(killer?: Entity): void {
    if (this._dying) return;

    this._dying = true;

    this.startModelOneshotAnimations(this._deathAnimations);
    this.stopFacing();
    this.stopMoving();
    this.dropItems();

    if (this._combatExperienceReward > 0 && killer instanceof GamePlayerEntity) {
      // Combat now awards lumber experience since this is a lumber-focused game
      killer.adjustSkillExperience(SkillId.LUMBER, this._combatExperienceReward);
      killer.gamePlayer.eventRouter.emit(BaseEntityPlayerEvent.KILLED, { entity: this });
    }

    setTimeout(() => this.despawn(), this._deathDespawnDelayMs);
  }

  public dropItems(): void {
    if (!this.world || !this._deathItemDrops || this._deathItemDrops.length === 0) return;

    const maxDrops = Math.floor(Math.random() * (this._deathItemMaxDrops ?? 1) + 1);

    for (let i = 0; i < maxDrops; i++) {
      const selectedDrop = this._pickRandomDeathItemDrop();
      if (!selectedDrop) continue;

      const min = selectedDrop.minQuantity ?? 1;
      const max = selectedDrop.maxQuantity ?? 1;
      const quantity = selectedDrop.quantity ?? Math.floor(Math.random() * (max - min + 1)) + min;
      
      const item = selectedDrop.itemClass.create({ quantity });
      item.spawnEntityAsEjectedDrop(this.world, this.position);
    }
  }

  public faceTowards(target: Vector3Like, faceSpeed: number) {
    this.pathfindingController.face(target, faceSpeed);
  }

  public interact(interactor: GamePlayerEntity): void {
    if (this._dialogueRoot) {
      interactor.setCurrentDialogueEntity(this);
      this.showDialogue(interactor, this._dialogueRoot.dialogue);

      if (this._rotatesOnInteract) {
        this.faceTowards(interactor.position, 8);
      }
    }
  }

  public jump(height: number) {
    this.pathfindingController.jump(height);
  }

  public moveTo(target: Vector3Like, speed: number = this._moveSpeed, options?: MoveOptions) {
    this.pathfindingController.move(target, speed, options ?? this._moveOptions);
  }

  public pathfindTo(target: Vector3Like, speed: number = this._moveSpeed, options?: PathfindingOptions) {
    this.pathfindingController.pathfind(target, speed, options ?? this._pathfindingOptions);
  }

  public progressDialogue(interactor: GamePlayerEntity, optionId: number): void {
    // Try local dialogue options first, then quest dialogue options with validation
    const selectedOption = this._optionMap.get(optionId) || 
                          QuestRegistry.getValidQuestDialogueOptionForNPC(this.constructor as typeof BaseEntity, optionId, interactor);

    if (!selectedOption) return;
    if (selectedOption.isSelectable && !selectedOption.isSelectable(interactor)) return;

    if (selectedOption.onSelect) {
      selectedOption.onSelect(interactor);
    }

    if (selectedOption.nextDialogue) {
      this.showDialogue(interactor, selectedOption.nextDialogue);
    }
  }

  public override spawn(world: World, position: Vector3Like, rotation?: QuaternionLike) {
    super.spawn(world, position, rotation);
    this._nameplateSceneUI.load(world);
  }

  public showDialogue(interactor: GamePlayerEntity, dialogue: BaseEntityDialogue): void {
    if (!this._dialogueRoot) return;

    const isRootDialogue = this._dialogueRoot.dialogue === dialogue;
    
    let questDialogueRootOptions: BaseEntityDialogueOption[] = [];

    if (isRootDialogue) {
      questDialogueRootOptions = QuestRegistry.getQuestRootDialogueOptionsForNPC(this.constructor as typeof BaseEntity, interactor);
    }

    const allDialogueOptions = [ ...questDialogueRootOptions, ...(dialogue.options || []) ];

    interactor.player.ui.sendData({
      type: 'dialogue',
      avatarImageUri: this._dialogueRoot.avatarImageUri,
      name: this.name,
      title: this._dialogueRoot.title,
      text: dialogue.text,
      options: allDialogueOptions.map(option => {
        if (option.isSelectable && !option.isSelectable(interactor)) {
          return null;
        }

        return {
          id: option._id,
          text: option.text,
          dismiss: option.dismiss,
          pureExit: option.pureExit ?? false,
          isQuestRoot: isRootDialogue && option._id && option._id >= QUEST_DIALOGUE_OPTION_START_ID,
        };
      }).filter(Boolean),
    });
  }

  public stopFacing() {
    this.pathfindingController.stopFace();
  }

  public stopMoving() {
    this.pathfindingController.stopMove();
  }

  public stopWandering() {
    if (this._wanderTimeout) {
      clearTimeout(this._wanderTimeout);
      this._wanderTimeout = undefined;
    }
  }

  public takeDamage(damage: number, attacker?: Entity): void {
    this.adjustHealth(-damage, attacker);
  }

  public wander(speed: number = this._moveSpeed, options: WanderOptions): void {
    // Basic validation and early exit for invalid states
    if (this._dying || !this.world || speed <= 0 || options.maxWanderRadius <= 0) return;

    // Allow subclasses to defer wandering for other behaviors
    if (this.shouldDeferWander()) {
      const { idleMinMs, idleMaxMs } = options;
      const idleTimeMs = Math.floor(Math.random() * (idleMaxMs - idleMinMs + 1)) + idleMinMs;
      this._wanderTimeout = setTimeout(() => this.wander(speed, options), idleTimeMs);
      return;
    }

    this.stopWandering();

    const { idleMinMs, idleMaxMs, maxWanderRadius, moveOptions } = options;
    const idleTimeMs = Math.floor(Math.random() * (idleMaxMs - idleMinMs + 1)) + idleMinMs;

    this._wanderTimeout = setTimeout(() => {
      if (this._dying || !this.world) return;

      const offsetX = (Math.random() - 0.5) * 2 * maxWanderRadius;
      const offsetZ = (Math.random() - 0.5) * 2 * maxWanderRadius;
      const target = {
        x: this.position.x + offsetX,
        y: this.position.y,
        z: this.position.z + offsetZ,
      };

      this.faceTowards(target, this._faceSpeed);
      this.moveTo(target, speed, moveOptions);

      const travelTimeMs = Math.max(500, ((offsetX + offsetZ) / speed) * 1000);
      this._wanderTimeout = setTimeout(() => this.wander(speed, options), travelTimeMs);
    }, idleTimeMs);
  }

  protected setupNameplateUI(): void {
    this._nameplateSceneUI = new SceneUI({
      attachedToEntity: this,
      offset: { x: 0, y: this.height / 2 + 0.25, z: 0 },
      templateId: 'entity-nameplate',
      viewDistance: this._nameplateViewDistance,
      state: {
        name: this.name,
        className: this.constructor.name,
        health: this.health,
        interactable: this.isInteractable,
        interactActionText: this.interactActionText,
        maxHealth: this.maxHealth,
        type: this._nameplateType,
      },
    });
  }

  protected shouldDeferWander(): boolean {
    return false; // override in subclasses to prevent wandering
  }

  private _buildDialogueOptionMap(): void {
    if (!this._dialogueRoot) return;
    
    let currentId = 0;
    
    const assignOptionIds = (dialogue: BaseEntityDialogue): void => {
      if (dialogue.options) {
        for (const option of dialogue.options) {
          option._id = currentId;
          this._optionMap.set(currentId, option);
          currentId++;
          
          if (option.nextDialogue) {
            assignOptionIds(option.nextDialogue);
          }
        }
      }
    };
    
    assignOptionIds(this._dialogueRoot.dialogue);
  }

  private _pickRandomDeathItemDrop(): BaseEntityItemDrop | null {
    if (this._deathItemDropsTotalWeight <= 0) return null;

    const random = Math.random() * this._deathItemDropsTotalWeight;
    let cumulativeWeight = 0;

    for (const drop of this._deathItemDrops) {
      cumulativeWeight += drop.weight;
      if (random < cumulativeWeight) {
        return drop;
      }
    }

    return null;
  }
}
